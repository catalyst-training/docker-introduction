<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Introduction to Docker - Catalyst Training</title>

        <meta name="author" content="Catalyst">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/catalyst.css" id="theme">
        <link rel="stylesheet" href="css/font-awesome.css">

        <!-- For syntax highlighting -->
        <!-- <link rel="stylesheet" href="lib/css/zenburn.css"> -->
        <link rel="stylesheet" href="lib/css/catalyst-syntax.css">

        <!-- If the query includes 'print-pdf', include the PDF print sheet -->
        <script>
            if( window.location.search.match( /print-pdf/gi ) ) {
                var link = document.createElement( 'link' );
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
                document.getElementsByTagName( 'head' )[0].appendChild( link );
            }
        </script>

        <style>
            /* Add the ability to omit slides from the printed version (has to be after the print include)*/
            @media print {
                .reveal .slides section.no-print {
                    display: none !important;
                    visibility: hidden !important;
                }
            }
        </style>
        <style>
            .reveal h1, .reveal h2, .reveal h3 {
                color: #ba2025;
            }
        </style>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->

        <!-- Please put any custom styles here -->
        <style>

        </style>
    </head>

    <body>

        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
                <!-- Cover slide -->
                <section>
                    <h1 class="catalyst-logo">Catalyst</h1>
                    <h3>Intro to Docker</h3>
                    <p class="small-text">
                        Presented by <a href="#">Travis Holton</a>
                    </p>
                </section>

                <section>
                    <h3>Administrivia</h3>
                    <ul>
                      <li>Bathrooms</li>
                      <li>Fire exits</li>
                    </ul>
                </section>

                <section>
                    <h3>This course</h3>
                    <ul>
                        <li>Makes use of official Docker docs</li>
                        <li>A mix of command line and theory</li>
                        <li>Assumes no prior Docker knowledge</li>
                        <li>Assumes familiarity with the linux shell</li>
                        <li>Assumes we are using ubuntu (trusty)</li>
                        <li>Has some helper scripts</li>
                    </ul>
                </section>

                <section>
                    <h3>Aims</h3>
                    <ul>
                        <li>Understand how to use Docker on the command line</li>
                        <li>Understand where Docker can be used</li>
                        <li>Appreciation of the larger ecosystem</li>
                        <li>Get peole thinking about where they could use Docker</li>
                        <li>Get people using the technology</li>
                    </ul>
                </section>
                
                <section>
                    <section>
                        <h2>Run our first Docker image</h2>
                    </section>
                    <section>
                        <h3>
                            Pull an image 
                        </h3>
                        <pre>docker pull alpine</pre>
                    </section>
                    <section>
                        <pre>docker image ls
REPOSITORY              TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
alpine                 latest              c51f86c28340        4 weeks ago         1.109 MB
hello-world             latest              690ed74de00f        5 months ago        960 B
                        </pre>
                    </section>


                </section>



                <section>
                    <h3>Understanding Docker</h3>
                    <p><a
                        href="https://docs.docker.com/engine/docker-overview/">https://docs.docker.com/engine/docker-overview/</a>
                    <a href="https://docs.docker.com/engine/docker-overview/">(cache)</a></p>
                    <aside class="notes">
                        <ul>
                      <li>Expalin architecture diagram (Commands and components).</li>
                      <li>Client vs daemon.</li>
                      <li>Union file systems; each command in a Dockerfile creates a new layer in an image.</li>
                      <li>Docker's use of UFS separates it from other container solutions.</li>
                      <li>Execute the "docker run" command and go through the list of steps it does.
                        <ul>
                          <li>Use sudo, unless you are in the Docker group (because of kernel feature permissions)</li>
                          <li>-i for interactive mode, -t for pseudo-tty allocation (Both let you use bash like a terminal)</li>
                        </ul></li>
                      <li>Namespaces => isolation of filesystem and kernel features.</li>
                      <li>Control groups => resource limiting.</li>
                      <li>Different container format avaialble, default is libcontainer</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>What is containerization?</h3>
                    <ul>
                        <li>
                            An operating system level virtualization method for
                            running distributed applications without launching an
                            entire VM.
                        </li>
                        <li>
                            Multiple isolated systems run on a single host and
                            access a single kernel
                        </li>
                        <li>
                            Key benefits:
                            <ul>
                                <li>Lightweight - Places less strain on overall resources.</li>
                                <li>Efficiency gains in storage, CPU</li>
                                <li>Portability
                                    <aside class="notes">
                                        Same application container can run on any system or cloud.
                                    </aside>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </section>
                
                <section>
                    <h3>Decoupling</h3>
                    <ul>
                        <li>Application stack is no longer coupled to machine it is running on</li>
                        <li>Allows a service to have the most appropriate stack without needing to consider conflicts with and dependencies of other services (eg python versions)</li>
                        <li>Services can be run in the most optimal location for a given organisation</li>
                        <li>Services can be upgraded and scaled independently</li>
                        <li>Services boundaries can define areas of responsibility</li>
                        <li>Configuration is coupled with the application</li>
                        <li>Service vs. Machine</li>
                    </ul>
                    <aside class="notes">Scale services, not machines. You *can* treat machines like cattle, not pets.</aside>
                </section>
                <!-- Large image slide -->
                <section class="image-slide">
                    <h2>Lightweight</h2>
                    <img src="img/docker.png" alt="">
                    <aside class="notes">Remember: Docker containers are all tied to the same kernel.</aside>
                </section>



                
                
                <section>
                    <h3>What is Docker?</h3>
                    <ul>
                        <li>Docker is an open-source platform for creating,
                            running, and distributing software "containers"
                            that bundle software applications with all of
                            their dependencies.

                            <li><a href="https://docs.docker.com/engine/understanding-docker/#what-is-the-docker-platform">Docker Platform</a></li>

                            <li><a href="https://docs.docker.com/engine/understanding-docker/#what-is-docker-engine">Docker Engine</a></li>
                        </li>
                        
                    </ul>
                </section>


                <section>
                    <h3>Why Docker?</h3>
                    <ul>
                        <li>Containers generally lightweight compared to traditional virtualization</li>
                        <li>Consistency across dev/test/prod</li>
                        <li>Easy to modify, update and scale</li>
                        <li>Dependency encapsulation and decoupling</li>
                        <li>Enables (requires?) new workflows</li>
                    </ul>
                </section>
                <section>
                    <h3>Docker Portability</h3>

                    <ul>
                        <li>Any modern Linux (RHEL, CentOS, Ubuntu LTS, etc.), OSX, Windows</li>
                        <li>Lightweight Docker optimized Linux distributions (CoreOS, Project Atomic, RancherOS, etc.)</li>
                        <li>Private clouds (OpenStack, Vmware)</li>
                        <li>Public clouds (AWS, Azure, Rackspace, Google)</li>
                    </ul>

                </section>
                <section>
                    <h3>Docker popularity</h3>
                    <ul>
                        <li>Linux containers are not new, but Docker
                            makes it easier to build and ship them.</li>
                        <li>Containers are intended to do for software
                            deployment what the shipping container did for
                            the shipping industry.</li>
                        <li>Containers are comparable to virtual
                            machines, but there are important differences.</li>
                    </ul>
                </section>

                <!-- Large image slide -->
                <section class="image-slide">
                    <h2>Simple Workflow</h2>
                    <img src="http://blog.octo.com/wp-content/uploads/2014/01/Diapositive1.png" alt="">
                    <aside class="notes"><ul>
                      <li>Docker workflows are comparable to Git workflows.</li>
                      <li>Always specify tags (or SHAs).</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>Docker Engine</h3>
                    <img src="img/engine-components-flow.png" alt="Ambassador">
                </section>


                <section>
                    <h3>Components of Docker</h3>
                    <ul>
                        <li>Images
                            <ul>
                                <li>The build component</li>
                            </ul>
                        </li>
                        <li>Containers
                            <ul>
                                <li>The run component</li>
                            </ul>
                        </li>
                            
                        <li>Registries
                            <ul>
                                <li>The distribution component</li>
                            </ul>
                        </li>
                    </ul>
                    <aside class="notes">Remember: Images are like templates/classes, containers are like instances/objects.</aside>
                </section>
                

                <!-- Large image slide -->
                <section class="image-slide">
                    <h2>Containers and Images</h2>
                    <img
                    src="http://alandargan.com/wp-content/uploads/2014/11/Docker2.png" alt="">
                </section>
<section>
                    <h3>Components of Docker</h3>
                    <ul>
                        <li>Images</li>
                            <ul>
                                <li>Read only template for creating containers</li>
                                <li>
                                    Can be built and distributed (by anyone)
                                </li>
                                <li>Can be based on or extended by other
                                    images</li>
                            </ul>
                        <li>Containers</li>
                            <ul>
                                <li>An actual running instance of an image</li>
                                <li>Read write</li>
                                <li>Encasulates your application and its dependencies</li>
                            </ul>
                        <li>Registries
                            <ul>
                                <li>Repository of images</li>
                            </ul>
                        </li>
                    </ul>
                    <aside class="notes">Remember: Images are like templates/classes, containers are like instances/objects.</aside>
                </section>

                

                <section>
                    <h3>Scripts</h3>
                    <ul>
                        <li>Designed to be run on trusty training machines</li>
                        <li>docker-setup.sh - ensures required software is installed</li>
                        <li>user-setup.sh - sets up environment variables for our user</li>
                        <li>docker-course.sh - list or run the course commands</li>
                    </ul>
                </section>

                <section>
                    <h3>Checkout code and examples</h3>
                    <pre><code data-trim contenteditable>
    $ git clone https://github.com/heytrav/docker-training
                    </code></pre>
                </section>
                <section>
                    <h3>Setup</h3>
                    <p>lets setup our environment now</p>
                    <pre><code data-trim contenteditable>
cd docker-training
source ./user-setup.sh
                    </code></pre>
                </section>
                <section>
                    <h3>Install Docker</h3>
                    <pre><code data-trim contenteditable>
    $ sudo ./docker-setup.sh
                    </code></pre>
                </section>
                <section>
                    <h3>Docker architecture</h3>
                    <pre>
    $ ps waux | grep docker 
    $ sudo docker images
                    </pre>

                    <img src="img/architecture.svg" alt="Architecture">
                </section>
                <section>
                    <h3>Course script</h3>
                    <p>By default this script outputs all the commands you will need to run</p>
                    <pre><code data-trim contenteditable>
$ sudo ./docker-course.sh -h

Usage: sudo ./docker-course.sh [OPTIONS]

    -h        this help
    -s        takes an integer, indicates that we should stop at this section
    -r        replay, runs all the commands without user input
    -i        interactive replay, requires keypresses to run commands
                    </code></pre>
                    <p>try it now</p>
                    <pre><code data-trim contenteditable>
sudo ./docker-course.sh -s 3
                    </code></pre>
                </section>

                <section>
                    <h3>1: Dockerizing applications</h3>
                    <a
                           href="https://docs.docker.com/engine/tutorials/dockerizing/">https://docs.docker.com/engine/tutorials/dockerizing/</a> <a href="http://webcache.googleusercontent.com/search?q=cache:https://docs.docker.com/userguide/dockerizing">(cache)</a>
                       <aside class="notes"><ul>
                               <li>Run simple container.</li>
                               <li>Run interactive container.</li>
                               <li>Run daemonized container.</li>
                               <li>Talk about container IDs.</li>
                               <li>docker ps (with -a for non-running containers)</li>
                               <li>Talk about container names (automatic, and set).</li>
                               <li>docker logs {container} (with -f to follow continuing output)</li>
                               <li>docker stop {container}</li>
                           </ul></aside>
                </section>


                


                <section>
                    <section>
                        <h3>2: Working with containers</h3>
                        <a
                            href="https://docs.docker.com/engine/tutorials/usingdocker/">https://docs.docker.com/engine/tutorials/usingdocker/</a> <a href="http://webcache.googleusercontent.com/search?q=cache:https://docs.docker.com/userguide/usingdocker">(cache)</a>
                        <aside class="notes"><ul>
                                <li>Docker version</li>
                                <li>Help: docker [command] --help</li>
                                <li>Run web server, explain -P for auto port-mapping.</li>
                                <li>Only non-official images have slashes in the name (which is the DockerHub account name)</li>
                                <li>Docker client defaults to DockerHub, but it can be made to point to another registry (but it is difficult).</li>
                                <li>docker ps "-l" option for last running container.</li>
                                <li>Note PORTS in docker ps output</li>
                                <li>And use -p for custom mappings.</li>
                                <li>Docker port {container} 5000</li>
                                <li>docker logs -f {container} (For web app logs)</li>
                                <li>docker top {container} (To view top output for processes in container (with PIDs of the host, not the container))</li>
                                <li>docker inspect {container} (For container info)</li>
                                <li>docker {start, stop, restart}</li>
                                <li>Ports auto-allocated with -P may be different after restart.</li>
                                <li>docker rm (with stop first)</li>
                            </ul></aside>
                    </section>

                    <section>
                        <h3>2: Working with containers</h3>
                        <ul>
                            <li>Run a basic application</li>
                            <li>Run a more complex web application</li>
                            <li>Some networking</li>
                        </ul>
                    </section>
                    <section>
                        <h3>More Examples</h3>
                    </section>

                    <section>
                        <h3>Talking to our detached container</h3>
                        <pre>
                        
$ docker ps -l

CONTAINER ID  IMAGE                   COMMAND...
bc533791f3f5  training/webapp:latest  python app.py ...

$ docker logs -f <container>                        
                        </pre>
                        <p>Meanwhile in another shell</p>

                        <pre>
curl http://&lt;hostname&gt;:32768
Hello world!%
                        </pre>
                    </section>
                    <section>
                        <h3>Create, start, stop and remove a container</h3>
                        <pre>
$ docker create --name myflaskapp -p 8080:5000 training/webapp python app.py
a842945e2414132011ae704b0c4a4184acc4016d199dfd4e7181c9b89092de13
$ docker ps -a

CONTAINER ID        IMAGE                  COMMAND...
8a73bcb9b7b8        training/webapp        "python app.py"...

$ docker start myflaskapp
a842945e2414

$ docker ps
CONTAINER ID        IMAGE               COMMAND
8a73bcb9b7b8        training/webapp     "python app.py"...

$ docker stop myflaskapp
$ docker rm myflaskapp
                        </pre>
                    </section>
                </section>

                <section>
                    <h3>3: Get started with images</h3>
<a
    href="https://docs.docker.com/engine/tutorials/dockerimages/">https://docs.docker.com/engine/tutorials/dockerimages/</a> <a href="http://webcache.googleusercontent.com/search?q=cache:https://docs.docker.com/userguide/dockerimages">(cache)</a>
                    <aside class="notes"><ul>
                      <li>docker images (To list images)</li>
                      <li>Careful not to chew up space with too many images.</li>
                      <li>An image is a base image, plus all FS layers on top.</li>
                      <li>Talk about tags (default tag when none is specified is latest)</li>
                      <li>docker pull centos (Pulling independent of running)</li>
                      <li>docker search sinatra</li>
                      <li>docker pull training/sinatra</li>
                      <li>Run the container, make changes, run commit.</li>
                      <li>commit creates a new image using a read-only version of the UFS layer the changes were made to.</li>
                      <li>Generally better to use a Dockerfile (it must have that name)</li>
                      <li>Create sinatra folder+Dockerfile, and explain contents</li>
                      <li>Each instruction in a Dockerfile creates a new layer.</li>
                      <li>docker build</li>
                      <li>Everything in the same directory as the Dockerfile is sent to the Docker daemon as "context" (so don't put a Dockerfile in your home directory).</li>
                      <li>To keep image sizes small, remove apt-cache (in the same instruction as installing dependencies), and remove other unnecessary cruft before it is added in a layer.</li>
                      <li>Max layers: 127</li>
                      <li>docker tag (To tag an image)</li>
                      <li>Digests don't seem to work correctly, and seem to overlap with SHA IDs.</li>
                      <li>You can push to DockerHub</li>
                      <li>docker rmi (To remove images, not to be confused with rm for containers)</li>
                    </ul></aside>
                </section>

                <section>
                    <h3>4: Networking containers</h3>
<a
    href="https://docs.docker.com/engine/tutorials/networkingcontainers/">https://docs.docker.com/engine/tutorials/networkingcontainers/</a> (new in 1.9 was <a href="https://docs.docker.com/engine/userguide/networking/default_network/dockerlinks/">Dockerlinks</a>)
                    <aside class="notes"><ul>
                      <li>Networking used to be handled through "Docker links" (one way exposing of ports between containers), which are now deprecated.</li>
                      <li>docker run --name (Naming a container)</li>
                      <li>You can create networks for your containers to sit on (specifying a driver (e.g. bridge driver on local machine, overlay driver across machines))</li>
                      <li>You'll want to create your own networks to isolate containers from each other in more complex setups.</li>
                      <li>List networks with: docker network ls</li>
                      <li>"bridge" is a special network that all cotnainers are added to by default.</li>
                      <li>You can "docker inspect {network}" to find out container IP addresses</li>
                      <li>docker network create</li>
                      <li>docker network connect/disconnect</li>
                      <li>Start a container on a network with --net</li>
                      <li>Inspect a container to see network information (it can be on multiple networks).</li>
                      <li>Start 2 containers on the same network, and ping each other.</li>
                      <li>When you connect a container to a network, Docker updates /etc/hosts on the other hosts so they can refer to it by its container name.</li>
                    </ul></aside>
                </section>

                <section>
                    <h3>5: Managing data in containers</h3>
<a
    href="https://docs.docker.com/engine/tutorials/dockervolumes/">https://docs.docker.com/engine/tutorials/dockervolumes/</a> <a href="http://webcache.googleusercontent.com/search?q=cache:https://docs.docker.com/userguide/dockervolumes">(cache)</a>
                    <aside class="notes"><ul>
                      <li>Data volumes are like the "mount" command; they bypass the UFS.</li>
                      <li>You can mount a directory from the host, or just a standalone volume.</li>
                      <li>docker run -v /webapp OR specify in Dockerfile</li>
                      <li>You can set read-only permissions on a volume (:ro).</li>
                      <li>A container's volumes are not deleted when it is deleted.</li>
                      <li>docker inspect {container} (To see volume info under "Mounts")</li>
                      <li>docker run -v /src/webapp:/opt/webapp</li>
                      <li>host_directory:container_directory</li>
                      <li>You can mount individual files</li>
                      <li>Pattern: Put all your data volumes in a single container, then use --volumes-from to share them with other containers. This means that you can safely delete the other containers without losing a container with a reference to the volume.</li>
                      <li>To remove volumes along with a container, use: docker rm -v</li>
                      <li>Removing a container without removing volumes will create dangling volumes which will need to be manually deleted.</li>
                    </ul></aside>
                </section>

                <section>
                    <h3>6: Get started with Docker Hub</h3>
<a
    href="https://docs.docker.com/engine/tutorials/dockerrepos/">https://docs.docker.com/engine/tutorials/dockerrepos/</a> <a href="http://webcache.googleusercontent.com/search?q=cache:https://docs.docker.com/userguide/dockerrepos">(cache)</a>
                    <aside class="notes"><ul>
                      <li>DockerHub has similar webhook and automation capabilities to GitHub.</li>
                    </ul></aside>
                </section>


<!--
   -                <section>
   -                    <section>
   -                        <h2>Cookbook Examples</h2>
   -                    </section>
   -
   -                    <section>
   -                        <h3>Run Hello world in busy box</h3>
   -                        <pre> $ docker run busybox echo hello world 
   -                        
   -Unable to find image 'busybox' locally
   -busybox:latest: The image you are pulling has been verified
   -511136ea3c5a: Pull complete
   -df7546f9f060: Pull complete
   -e433a6c5b276: Pull complete
   -e72ac664f4f0: Pull complete
   -Status: Downloaded newer image for busybox:latest
   -hello world
   -                        </pre>
   -                    </section>
   -
   -                    <section>
   -                        <h3>Run a container in detached mode</h3>
   -                        <pre>$ docker run -d  -p 1234:1234 python:3.5 python -u -m http.server 1234
   -Unable to find image 'python:3.5' locally
   -3.5: Pulling from library/python
   -8ad8b3f87b37: Pull complete
   -751fe39c4d34: Pull complete
   -ae3b77eefc06: Pull complete
   -7783aac582ec: Pull complete
   -b7fc86da4ddd: Pull complete
   -25af1114570f: Pull complete
   -fa675d7a898c: Pull complete
   -Digest: sha256:e73edc3b2c53fd775473ab99056a331dd719f914a8e8bd4e0a2e97bf1c95524e
   -Status: Downloaded newer image for python:3.5
   -b207c64501437c7f70c7d5fc6dacc2280cb860d67b966f03b98ce725ce23d128
   -                        </pre>
   -
   -                    </section>
   -                    <section>
   -                        <h3>Run a container in detached mode</h3>
   -                        <pre>$ docker ps
   -
   -CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
   -62e9b7c9be5b        python:3.5          "python -u -m http.se"   5 seconds ago       Up 4 seconds        0.0.0.0:1234->1234/tcp   berserk_murdock
   -
   -$ docker logs -f <container>                        
   -                        </pre>
   -                    </section>
   -
   -                </section>
   -->
                <section>
                <!-- Large image slide -->
                <section class="image-slide">
                    <h2>7: Layering (via a Union file system)</h2>
                    <img src="https://assets.digitalocean.com/articles/docker_ecosystem/Container-Overview.png" alt="">
                </section>
                <section>
                    <h3>7: Layers</h3>
                    <ul>
                        <li>dockviz</li>
                    <pre><code data-trim contenteditable>
sudo dockviz images --tree

sudo dockviz images -d | dot -Tpng -o images.png && eog images.png && rm images.png
sudo dockviz containers -d | dot -Tpng -o containers.png && eog containers.png && rm containers.png
                    </code></pre>
                    </ul>
                    <aside class="notes">Local tool to visualise layers.</aside>
                </section>

                <section>
                    <h3>7: imagelayers.io</h3>
                    <p><a href="https://imagelayers.io/?images=java:latest,golang:latest,node:latest,python:latest,php:latest,ruby:latest">https://imagelayers.io/</a><p>
                    <aside class="notes">Service to visualise layers.</aside>
                </section>

                <section>
                    <h3>7: Docker history</h3>
                    <p>Show the history (layers) of an image</p>
                    <pre><code data-trim contenteditable>
$ docker history cb7ea125b1fc
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
cb7ea125b1fc        3 months ago        /bin/sh -c gem install sinatra                  18.44 MB
0c0869a12bcd        3 months ago        /bin/sh -c apt-get update && apt-get install    112.7 MB
6d4946999d4f        3 months ago        /bin/sh -c #(nop) CMD ["/bin/bash"]             0 B
9fd3c8c9af32        3 months ago        /bin/sh -c sed -i 's/^#\s*\(deb.*universe\)$/   1.895 kB
435050075b3f        3 months ago        /bin/sh -c echo '#!/bin/sh' > /usr/sbin/polic   194.5 kB
428b411c28f0        3 months ago        /bin/sh -c #(nop) ADD file:b3447f4503091bb6bb   188.1 MB
                    </code></pre>
                </section>

                <section>
                    <h3>7: Docker Diff</h3>
                    <p>Show the differences between a container's filesystem and its base image</p>
                    <pre><code data-trim contenteditable>
$ sudo docker run --name=sleepy_cori -it ubuntu:latest /bin/bash
root@e888e0fef39e:/# echo flubber > test.txt
root@e888e0fef39e:/# exit

$ sudo docker ps -l
CONTAINER ID IMAGE         COMMAND     CREATED        STATUS                    PORTS NAMES
e888e0fef39e ubuntu:latest "/bin/bash" 57 seconds ago Exited (0) 11 seconds ago       sleepy_cori

$ sudo docker restart sleepy_cori
sleepy_cori

$ sudo docker attach sleepy_cori
root@e888e0fef39e:/#
                    </code></pre>
                    <aside class="notes">Make changes to a container.</aside>
                </section>

                <section>
                    <h3>7: Docker Diff</h3>
                    <pre><code data-trim contenteditable>
root@e888e0fef39e:/# apt-get install mtr-tiny
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following NEW packages will be installed:
mtr-tiny
0 upgraded, 1 newly installed, 0 to remove and 0 not upgraded.
Need to get 41.7 kB of archives.
After this operation, 126 kB of additional disk space will be used.
Get:1 http://archive.ubuntu.com/ubuntu/ trusty/main mtr-tiny amd64 0.85-2 [41.7 kB]
Fetched 41.7 kB in 1s (38.4 kB/s)
Selecting previously unselected package mtr-tiny.
(Reading database ... 11528 files and directories currently installed.)
Preparing to unpack .../mtr-tiny_0.85-2_amd64.deb ...
Unpacking mtr-tiny (0.85-2) ...
Setting up mtr-tiny (0.85-2) ...
root@e888e0fef39e:/# exit
                    </code></pre>
                    <aside class="notes">Make more changes to a container.</aside>
                </section>

                <section>
                    <h3>7: Docker Diff</h3>
                    <pre><code data-trim contenteditable>
$ sudo docker ps -l
CONTAINER ID IMAGE         COMMAND     CREATED       STATUS                    PORTS NAMES
e888e0fef39e ubuntu:latest "/bin/bash" 2 minutes ago Exited (0) 25 seconds ago       sleepy_cori

$ sudo docker diff sleepy_cori | head
C /root
A /root/.bash_history
A /test.txt
C /tmp
C /usr
C /usr/bin
A /usr/bin/mtr
C /usr/share
C /usr/share/doc
A /usr/share/doc/mtr-tiny
                    </code></pre>
                    <aside class="notes">View changes to a container.</aside>
                </section>

                <section>
                    <h3>7: Docker Diff</h3>
                    <p>Show the differences between a container's filesystem and its base image</p>
                    <pre><code data-trim contenteditable>
$ sudo find /var/lib/docker/ -type f -name 'test.txt' -exec md5sum {} \;
185320c3e9298cdbde3320ec32144980  /var/lib/docker/aufs/diff/e888e0fef39e6f7f249f33f0475e891aaef899cca9ed0ea39d2524e5f06be792/test.txt

$ sudo docker restart sleepy_cori
sleepy_cori

$ sudo docker exec sleepy_cori md5sum test.txt
185320c3e9298cdbde3320ec32144980  test.txt
                    </code></pre>
                    <aside class="notes">Show that files inside container can be found in the host filesystem.</aside>
                </section>

                <section>
                    <h3>7: Docker Diff what is AUFS?</h3>
                    <ul>
                        <li>Did you notice /var/lib/docker/aufs?</li>
                        <li><a href="http://aufs.sourceforge.net/">Advanced Multi Layered Unification Filesystem</a></li>
                    <pre><code data-trim contenteditable>
priority = []string{
"aufs",
"btrfs",
"devicemapper",
"vfs",
"overlayfs",
                    </code></pre>
                        <li>Details <a href="https://developerblog.redhat.com/2014/09/30/overview-storage-scalability-docker/">here</a></li>
                    </ul>
                    <aside class="notes">Different UFS available, priority order shown above. The first available on a system will be used, but it is overridable. Not all OS distributions can use them all.</aside>
                </section>


                </section>

                <section>
                <section>
                    <h3>8: More on Dockerfiles</h3>
                    <ul>
                        <li><a
                                href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/">Dockerfile Best Practices</a></li>
                        <li><a href="https://github.com/nginxinc/docker-nginx/blob/4e5332fa50a1f8f73657417c6bfe249bbb3b110d/dockerfile">Nginx Dockerfile</a></li>
                        <li><a href="https://github.com/docker-library/postgres/blob/8a9fbcb40f13ccc7762f278b9df611cabe22d300/9.5/dockerfile">Postgres Dockerfile</a></li>
                        <li><a href="https://labs.ctl.io/dockerfile-entrypoint-vs-cmd/">ENTRYPOINT vs CMD</a></li>
                    </ul>
                    <aside class="notes"><ul>
                      <li><strong>Dockerfile Best Practices</strong></li>
                      <li>Go over main points in recommendations</li>
                      <li>Explain layer caching, and cache-busting with changed lines and --no-cache=true</li>
                      <li>Never run apt-get upgrade or dist-upgrade (they may not work in a container), always depend on the base image to be updated.</li>
                      <li>Look at apt-get recommendations (update in same instruction, version pinning, clearing apt lists)</li>
                      <li>Prefer COPY instead of ADD (which has fancy features such as remote URLs and tar expansion)</li>
                      <li><strong>ENTRYPOINT vs CMD</strong></li>
                      <li>CMD is overriden by whatever the user supplies as the command.</li>
                      <li>ENTRYPOINT prefixes the command, so is good as a "wrapping command" for other subcommands. E.g. git</li>
                      <li>ENTRYPOINT can be overriden with --entrypoint</li>
                      <li>CMD can be used to contain default options for the ENTRYPOINT</li>
                      <li>Prefer CMD/ENTRYPOINT exec form (["/bin/ping" "-c" "3"]) over shell form ("ping -c 3", which is executed as "/bin/sh -c ping -c 3") so that the process itself is PID 1, not the shell (useful for Docker control signals).</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                    <ul>
                        <li>See <a href="https://labs.ctl.io/dockerfile-entrypoint-vs-cmd/">https://labs.ctl.io/dockerfile-entrypoint-vs-cmd/</a> for details</li>
                        <li>Lets look at some images: <a href="https://imagelayers.io/?images=debian:latest,ubuntu:latest,alpine:latest">https://imagelayers.io/?images=debian:latest,ubuntu:latest,alpine:latest</a></li>
                    <pre><code data-trim contenteditable>
$ sudo docker run -i -t debian
root@0f94a65e7d37:/# exit
$ sudo docker run -i -t alpine
Error response from daemon: No command specified
                    </code></pre>
                    </ul>
                </section>
                <section>
                    <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                    <pre><code data-trim contenteditable>
$ cat dockerfiles/ping-localhost/dockerfile
FROM debian:jessie
CMD ping localhost
$ sudo docker build -t demo dockerfiles/ping-localhost
$ sudo docker run -t demo
PING localhost (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.034 ms
64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.054 ms
64 bytes from localhost (127.0.0.1): icmp_seq=3 ttl=64 time=0.064 ms
$ docker run demo uname -a
Linux fac4960db319 3.13.0-66-generic #108-Ubuntu SMP Wed Oct 7 15:20:27 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux
                    </code></pre>
                </section>
                <section>
                    <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                    <ul>
                        <li>Use CMD when you want the user to have the choice of commands to run</li>
                        <li>Use ENTRYPOINT when you want to wrap a command</li>
                        <li>ENTRYPOINT can be overridden with the --entrypoint flag</li>
                    </ul>
                </section>
                <section>
                    <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                    <pre><code data-trim contenteditable>
$ cat dockerfiles/python/dockerfile
FROM python
ENTRYPOINT ["python"]
$ sudo docker build -t python dockerfiles/python
Sending build context to docker daemon 2.048 kB
Step 0 : FROM python
---> e7d942e7369d
Step 1 : ENTRYPOINT python
---> Using cache
---> c3b6fc104517
Successfully built c3b6fc104517
$ sudo docker run -ti python
Python 3.5.0 (default, Nov 11 2015, 10:39:25)
[GCC 4.9.2] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> exit()
$ sudo docker run --entrypoint uname -t python
Linux
                    </code></pre>
                </section>
                <section>
                    <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                    <pre><code data-trim contenteditable>
$ sudo docker run -d demo
f27197f4370c2981792ab3d09a0620c1c8f7c993cb66770ffc1f1aa6c4dfe021
$ docker ps -l
CONTAINER ID IMAGE     COMMAND                 CREATED        STATUS         PORTS NAMES
f27197f4370c dojo/demo "/bin/sh -c 'ping loc"  11 seconds ago Up 10 seconds        suspicious_leakey
$ sudo docker exec f27197f4370c ps -f
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 08:21 ?        00:00:00 /bin/sh -c ping localhost
root         5     1  0 08:21 ?        00:00:00 ping localhost
root         6     0  0 08:21 ?        00:00:00 ps -f
                    </code></pre>
                </section>
                <section>
                    <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                    <ul>
                        <li>Shell form vs Exec form</li>
                        <li>Don't mix and match</li>
                        <li>Use exec</li>
                    </ul>
                </section>
                <section>
                    <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                    <pre><code data-trim contenteditable>
$ cat dockerfiles/ping-localhost-exec/dockerfile
FROM debian:jessie
CMD ["ping", "localhost"]
$ sudo docker build -t demo dockerfiles/ping-localhost-exec/
...
$ sudo docker run -d demo
db7526643dbe7ec6d6f27aa707539aa67a3573a8adc7754372d8fce0fe824cfc
$ sudo docker exec db7526643dbe ps -f
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 08:27 ?        00:00:00 ping localhost
root         6     0  0 08:27 ?        00:00:00 ps -f
                    </code></pre>
                </section>
                <section>
                    <h3>8: Dockerfiles: ENTRYPOINT vs CMD</h3>
                    <pre><code data-trim contenteditable>
$ cat dockerfiles/ping-localhost-both/dockerfile
FROM debian:jessie
ENTRYPOINT ["/bin/ping","-c","3"]
CMD ["localhost"]
$ sudo docker build -t ping dockerfiles/ping-localhost-both
$ sudo docker run ping google.com
$ sudo docker run ping
                    </code></pre>
                </section>
                </section>

                <section>
                    <h3>9: Base images</h3>
                    <ul>
                        <li>Size is a major consideration ... deploy times ...</li>
                        <li>FROM empty ...</li>
                        <li><a href="http://www.busybox.net/">Busybox</a> - 5.6 MB, no package manager</li>
                        <li><a href="https://www.alpinelinux.org/">Alpine Linux</a> - distribution of choice for minimal containers - 5MB with a package manager (based on busybox)</li>
                        <li><a href="https://hub.docker.com/_/debian/">Debian</a> - Reccomended by Docker, smaller than Ubuntu - 85MB</li>
                        <li><a href="https://hub.docker.com/_/ubuntu/">Ubuntu</a> - Commonly used but quite big</li>
                        <li>Language images (<a href="https://hub.docker.com/_/golang/">golang</a>, <a href="https://hub.docker.com/_/python/">python</a> etc.) - Seem to be mostly based on Debian</li>
                        <li>See <a href="http://www.blang.io/posts/2015-04_how-to-build-the-smallest-docker-containers">1</a>, <a href="http://www.livewyer.com/blog/2015/02/24/slimming-down-your-docker-containers-alpine-linux">2</a>, <a href="https://docs.docker.com/articles/baseimages/">3</a></li>
                    </ul>
                </section>

                <section>
                <section>
                    <h3>10: Docker networking</h3>
                    <img src="http://www.linuxjournal.com/files/linuxjournal.com/ufiles/imagecache/large-550px-centered/u1002061/11833f1.png" alt="docker networking">
                    <aside class="notes"><ul>
                      <li>docker starts a "docker0" virtual bridge to handle host-container communication.</li>
                      <li>When a container starts, Docker creates a virtual interface on the host (e.g. veth9999999), which is connected to the eth0 interface of the container.</li>
                    </ul></aside>
                </section>

                <section>
                    <h3>10: Docker networking</h3>
                    <ul>
                        <li>docker0 virtual bridge</li>
                        <li>172.17.42.1/16 by default</li>
                        <li>Part of the 172.16.0.0/12 RFC 1918 space</li>
                        <li>Sets up virtual ether net ports on the host (eg veth31a763b)</li>
                        <li>Sets up a DOCKER Chain in iptables</li>
                        <li>Mounts hosts /etc/resolv.conf and /etc/hosts in containers</li>
                    </ul>
                </section>
                <section>
                    <h3>10: Docker networking</h3>
                    <pre><code data-trim contenteditable>
# try these commands your the host
# use your own container name
$ sudo iptables -L
$ sudo ip addr
$ sudo docker exec -it stoic_ramanujan findmnt
$ sudo cat $(sudo docker exec -it stoic_ramanujan findmnt | grep resolv | awk -F'[][]' '{ print $2 }')
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
nameserver 192.168.2.92
search wgtn.cat-it.co.nz lan
                    </code></pre>
                    <aside class="notes">Shows that the resolv.conf is mounted in the container, as well as iptables rules.</aside>
                </section>
                </section>

                <section>
                <section>
                    <h3>11: Exec vs Attach</h3>
                    <ul>
                        <li>Exec is specifically for running new processes in an already started container, be it a shell or some other process</li>
                        <li>Attach is for attaching to the running process, not for running an extra process in a container</li>
                    </ul>
                </section>
                <section>
                    <h3>11: Exec</h3>
                    <ul>
                        <li>The Docker exec command runs a <strong>new</strong> command (process) in a running container</li>
                    </ul>
                </section>
                <section>
                    <h3>11: Attach</h3>
                    <ul>
                        <li>Attach lets you view or interact with any running container's primary process (pid 1) </li>
                        <li>You can attach to the same contained process multiple times simultaneously, screen sharing style</li>
                        <li>View the output of your daemonized process</li>
                        <li>Not for running a new process in a container</li>
                    </ul>
                </section>
                </section>

                <section>
                    <h3>Some Concepts</h3>
                    <ul>
                        <li>Buzzwords ahead!</li>
                        <li><a href="http://radar.oreilly.com/2015/06/an-introduction-to-immutable-infrastructure.html">Immutable infrastructure</a></li>
                        <li><a href="https://blog.engineyard.com/2014/pets-vs-cattle">Cattle vs pets</a></li>
                        <li><a href="http://martinfowler.com/bliki/SnowflakeServer.html">Snowflake Servers</a> vs. <a href="http://martinfowler.com/bliki/PhoenixServer.html">Phoenix Servers</a></li>
                    </ul>
                    <aside class="notes"><ul>
                      <li>Immutable architecture: Instead of mutating an instance, replace it with a new one.</li>
                      <li>Pets (nursed back to health) vs. Cattle (replaced when sick)</li>
                      <li>Snowflake (unique) vs. Phoenix (constantly rising from the ashes of its predecessor)</li>
                    </ul></aside>
                </section>

                <!-- Immutable Infrastructure -->
                <section>
                <section>
                    <h3>Immutable Architecture/Infrastructure</h3>
                    <ul>
                        <li>Phoenix servers</li>
                        <li>The environment is defined in code</li>
                        <li>If you need to change _anything_ you create a new instance and destroy the old one</li>
                        <li>Docker makes it much more likely you will work in this way</li>
                        <li>Procedural vs Declarative</li>
                    </ul>
                    <aside class="notes">Docker basically forces you to not manually alter servers.</aside>
                </section>
                <!-- Large image slide -->
                <section class="image-slide">
                    <h2>Immutable Architecture</h2>
                    <img src="http://s.radar.oreilly.com/wp-files/2/2015/06/immutable_infrastructure.gif" alt="Immutable Architecture" height="600" width="800">
                </section>
                </section>

                <!-- Microservices -->
                <section>
                <section>
                    <h3>Microservices</h3>
                    <p>Cockcrofts definition: Loosely coupled service oriented architecture with bounded contexts</p>
                    <p>Eric Brewers: Microservice boundaries are language boundaries and team boundaries</p>
                </section>
                <section>
                    <h3>Microservices</h3>
                    <ul>
                        <li>A suite of small services, each running in its own process and communicating with lightweight mechanisms</li>
                        <li>Services can be implemented with entirely different stacks</li>
                        <li>Services can be developed, maintained, and updated independently</li>
                        <li>Often use well defined REST APIs to communicate</li>
                        <li>If a message bus/queue is used then its likely to be lightweight (ZeroMQ vs ESB)</li>
                    </ul>
                    <aside class="notes"><ul>
                      <li><a href="http://martinfowler.com/articles/microservices.html">http://martinfowler.com/articles/microservices.html</a></li>
                    </ul></aside>
                </section>
                <section>
                    <h3>Microservices</h3>
                    <ul>
                        <li>Often use a DevOps approach (you build it you run it)</li>
                        <li>Smart endpoints and dumb pipes</li>
                        <li>Decentralized Data Management with eventual consistency</li>
                        <li>Continuous integration and delivery</li>
                        <li>Design for failure (optimize MTTR (mean-time-to-repair))</li>
                    </ul>
                    <aside class="notes">Smart endpoints and dumb pipes: Communication mediums should be as simple/dumb as possible (e.g. simple message queue, REST); the logic should be in the app.</aside>
                </section>
                <section>
                    <h3><a href="https://www.nginx.com/blog/microservices-at-netflix-architectural-best-practices/">Microservices best practices</a></h3>
                    <ul>
                        <li>Create a Separate Data Store for Each Microservice</li>
                        <li>Keep Code at a Similar Level of Maturity</li>
                        <li>Do a Separate Build for Each Microservice</li>
                        <li>Deploy in Containers</li>
                        <li>Treat Servers as Stateless</li>
                    </ul>
                    <aside class="notes"><ul>
                      <li>Separate data stores: Use the best DBMS and schema for each service.</li>
                      <li>When doing new development, create a new microservice, rather than extending the existing one (so that you don't break it or make it less performant). You can merge the microservices later if needed.</li>
                      <li>Stateless: Cattle, not pets.</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>Containers and Microservices</h3>
                    <ul>
                        <li>Containers do not necessarily map to service or application boundaries</li>
                        <li>A service will often contain more than one container</li>
                        <li>A container is more like an OO Class - Brendan Burns @ Dockercon 2015</li>
                        <li>A container is a persistent object - Eric Brewer @ OSCon 2015</li>
                    </ul>
                    <aside class="notes">Containers are great for microservices, because they simplify the task of deploying many individual services, each with their own requirements.</aside>
                </section>
                <section>
                    <h3>Containers and Microservices: Requirements</h3>
                    <ul>
                        <li>Sharing among containers (eg filesystems)</li>
                        <li>Atomic co-scheduling of containers</li>
                        <li>Parameterization of containers</li>
                    </ul>
                    <aside class="notes"><ul>
                      <li>Volumes</li>
                      <li>Being able to spin up a bunch of containers together as a unit.</li>
                      <li>Parameters through environment variables for different environments.</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>Microservices - Resources</h3>
                    <ul>
                        <li><a href="http://martinfowler.com/articles/microservices.html">Microservices - Martin Fowler</a></li>
                        <li><a href="https://www.nginx.com/blog/microservices-at-netflix-architectural-best-practices/">Adopting Microservices at Netflix: Lessons for Architectural Design</a></li>
                        <li><a href="https://www.nginx.com/blog/adopting-microservices-at-netflix-lessons-for-team-and-process-design/">Adopting Microservices at Netflix: Lessons for Team and Process Design</a></li>
                        <li><a href="https://www.youtube.com/watch?v=e4jr6Ihz4Qo">Kubernetes: The Path to Cloud Native - Eric Brewer - OSCon 2105</a></li>
                        <li>Nginx blog Building Microservices series: <a href="https://www.nginx.com/blog/introduction-to-microservices/">1</a>,<a href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway">2</a>,<a href="https://www.nginx.com/blog/building-microservices-inter-process-communication/">3</a></li>
                        <li><a href="https://www.nginx.com/blog/microservices-at-netflix-architectural-best-practices/">Microservices best practices</a></li>
                    </ul>
                </section>
                </section>

                <section>
                    <h3>Devops</h3>
                    <ul>
                        <li>You build it you run it</li>
                        <li>With Docker it is easier to make a distinction between who "owns" the service and who "owns" the platform the service runs on</li>
                        <li>Because dev is like production the developer thinks about how it runs in production</li>
                    </ul>
                </section>

                 <!-- Continuous delivery -->
                <section>
                <section>
                    <h3>Continuous delivery</h3>
                    <ul>
                        <li>Automated Pipeline from developer commit to production deploy</li>
                        <li>Requires Continuous Integration where every commit triggers all the tests</li>
                        <li>Requires lots of tests</li>
                    </ul>
                </section>
                <section>
                  <h3>Continuous delivery</h3>
                  <img src="img/ci-diagram.png" alt="Continuous delivery">
                </section>
                <section>
                    <h3>Continuous delivery antipatterns</h3>
                    <ul>
                        <li>Deploying software manually</li>
                        <li>Deploying to a production-like environment only after development is complete</li>
                        <li>Manual configuration of production environments</li>
                        <li>Docker makes it difficult to do any of these</li>
                    </ul>
                </section>
                </section>

                 <!-- Where to start? -->
                <section>
                <section>
                    <h3>Containers: Where to start?</h3>
                    <ul>
                        <li>Building binaries</li>
                        <li>Prototypes you can share</li>
                        <li>Tutorials</li>
                        <li>Those small snowflakes</li>
                        <li>Build new functionality as microservices</li>
                        <li>Existing components that are already largely independent</li>
                        <li>Mix and match, containerise the bits that make sense</li>
                    </ul>
                </section>
                <section>
                    <h3>Examples</h3>
                    <ul>
                        <li><a href="https://blog.docker.com/2015/07/docker-three-ways-devops-3/">Distributing (scientific) data</a></li>
                        <li><a href="https://github.com/VISIONAI/clouddream">Distributing clouddream</a></li>
                        <li><a href="https://github.com/CenturyLinkLabs/golang-builder">Compiling go</a></li>
                    </ul>
                </section>
                 <!-- Large image slide -->
                <section class="image-slide">
                    <h2>Bosch Dreaming</h2>
                    <a href="img/Hieronymus_Bosch_003.jpg"><img src="img/Hieronymus_Bosch_003.jpg" alt="Bosch Dream" height="600" width="800"></a>
                </section>
                </section>

                <!-- ecosystem -->
                <section>
                <section>
                    <h3>Docker ecosystem</h3>
                    <ul>
                        <li>An explosion of tools</li>
                        <li>Hard to keep up</li>
                        <li>Lets have a quick look</li>
                    </ul>
                </section>
                <!-- Large image slide -->
                <section class="image-slide">
                    <h2>Docker ecosystem</h2>
                    <img src="img/docker-ecosystem.png" alt="Docker Ecosystem" height="600" width="800">
                    <aside class="notes"><ul>
                      <li>Orchestration: Managing the lifecycle of containers (starting, stopping, etc.) and distributing them across hosts in a cluster.</li>
                      <li>Service Discovery: Manage directories of where services running in containers can find each other in a cluster of hosts.</li>
                      <li>Networking: Virtual networks across hosts in a cluster</li>
                      <li>Linux: Underlying Linux technologies that Docker uses.</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>The stack</h3>
                    <ul>
                        <li>The LAMP stack equivalent</li>
                        <li>Container Orchestration Engines</li>
                        <li>Linux - Docker - COE - ?</li>
                        <li>Often LDK (Linux - Docker - Kubernetes)</li>
                        <li>Higher level projects build on this stack (eg OpenShift and CloudFoundry)</li>
                    </ul>
                </section>
                <section>
                    <h3>Docker ecosystem - Host OS</h3>
                    <p>Lightweight operating systems designed to run containers</p>
                    <ul>
                        <li><a href="https://coreos.com/">CoreOS</a> (systemd)</li>
                        <li><a href="http://www.projectatomic.io/">Project Atomic</a> (cut down RHEL)</li>
                        <li><a href="http://rancher.com/">Rancher</a> (Dockers all the way down)</li>
                        <li><a href="http://boot2docker.io/">boot2docker</a> (for windows/mac devs)</li>
                    </ul>
                </section>
                <section>
                    <h3>Docker ecosystem - Container Orchestration Engines</h3>
                    <p>Engine for orchestrating container workloads, term comes from the OpenStack Magnum project.</p>
                    <p>There are two main classes of orchestration tooling:</p>
                    <ul>
                        <li><strong>Simple orchestration tools</strong> for deploying on pet servers</li>
                        <li><strong>Distributed schedulers</strong> for deploying on cattle server farms</li>
                    </ul>
                </section>
                <section>
                    <h3>Simple orchestration tools</h3>
                    <ul>
                        <li>Tools to simply deploy containers onto servers.</li>
                        <li>Simple way to get many benefits of Docker in production.</li>
                        <li>E.g. Centurion, Helios, Docker modules for Ansible and Puppet.</li>
                    </ul>
                </section>
                <section>
                  <h3>Docker + Ansible Deployments</h3>
                  <img src="img/docker-ansible-diagram.png" height="600">
                </section>
                <section>
                    <h3>Distributed schedulers</h3>
                    <ul>
                        <li>Make a cluster appear to be a single computer.</li>
                        <li>More complex, but have more of the benefits associated with immutable infrastructure, etc.</li>
                        <li><a href="http://radar.oreilly.com/2015/10/swarm-v-fleet-v-kubernetes-v-mesos.html">Swarm v. Fleet v. Kubernetes v. Mesos</a></li>
                    </ul>
                </section>
                </section>

                <!-- Docker compose -->
                <section>
                <section>
                    <h3>Docker compose</h3>
                    <ul>
                        <li>Mainly used for spinning up multi-container development/testing environments.</li>
                        <li>Written in python rather than go like most of Docker</li>
                        <li>Comparable to vagrant</li>
                        <li>New lib written in go called <a href="http://rancher.com/our-journey-with-docker-compose-and-the-introduction-of-libcompose/">libcompose</a></li>
                        <li>Lots of documentation will mention (now obsolete) links, you can generally just remove links configuration.</li>
                    </ul>

                </section>
                <section>
                    <h3>Docker compose</h3>
                    <a href="https://docs.docker.com/compose/">Overview of Docker Compose</a> <a href="http://webcache.googleusercontent.com/search?q=cache:https://docs.docker.com/compose/">(cache)</a>
                </section>
                <section>
                    <h3>Docker compose - hands on</h3>
                    <a href="https://docs.docker.com/compose/gettingstarted/">Example app</a>
                </section>
                </section>

                <!-- Docker swarm -->
                <section>
                    <h3>Docker swarm</h3>
                    <ul>
                        <li>Native clustering for Docker</li>
                        <li>Use standard tools to interact with a cluster of Docker engines</li>
                        <li>Turn a group of Docker engines into a single, virtual Docker engine</li>
                        <li>Engines can be deployed using Docker machine (<a href="http://docs.catalystcloud.io/tutorials.html#create-an-a-cloud-vm-using-docker-machine">example</a>)</li>
                    </ul>
                </section>

                <!-- Kubernetes -->
                <section>
                <section>
                    <h3>Kubernetes</h3>
                    <ul>
                        <li>Container orchestrator</li>
                        <li>Started by Google</li>
                        <li>Inspired by Borg (Google's cluster management system)</li>
                        <li>Open source project written in Go</li>
                        <li>Cloud Native Computing Foundation</li>
                        <li>Manage applications not machines</li>
                    </ul>
                </section>
                <section>
                    <h3>Kubernetes Components</h3>
                    <ul>
                        <li>Pods - an ephemeral group of co-scheduled containers that together provide a service</li>
                        <li>Flat Networking Space - each pod has an IP and can talk to other pods, within a pod containers communicate via localhost (need to manage ports)</li>
                        <li>Labels - Key value pairs, used to label pods and other objects so the scheduler can operate on them</li>
                        <li>Services - stable endpoints comprised of one or more pods (external services are supported)</li>
                        <li>Replication Controllers - the orchestrator that controls and monitors the pods within a service (known as replicas)</li>
                    </ul>
                </section>
                <section>
                  <h3>Kubernetes Overview</h3>
                  <img src="img/kubernetes-diagram.png" alt="Kubernetes diagram">
                  <aside class="notes">The services and controllers actually run as processes on every node. The external load balancer is necessary to split traffic across the nodes, and once it reaches a node, the service will route it to the correct pod, or even a different node (see: http://www.dasblinkenlichten.com/kubernetes-101-external-access-into-the-cluster/).</aside>
                </section>
                <section>
                    <h3>Pods/Services</h3>
                    <ul>
                        <li>Co-locate containers</li>
                        <li>Shared volumes</li>
                        <li>IP address (important for port space and migration)</li>
                        <li>Unit of deployment and migration</li>
                        <li>Easy migration = high utilisation</li>
                        <li>Scale service by scaling pods</li>
                    </ul>
                </section>
                </section>

                 <!-- Managing state -->
                <section>
                <section>
                    <h3>Managing State</h3>
                    <p>"In a cluster of ephemeral containers application state must exist outside of the containers."</p>
                    <p>Ian Lewis, Google - <a href="https://speakerdeck.com/ianlewis/in-a-world-of-ephemeral-containers-how-do-we-keep-track-of-things-at-openstack-summit-tokyo">In a World of Ephemeral Containers, How Do We Keep Track of Things? @ OpenStack Summit Tokyo</a> (<a href="https://www.youtube.com/watch?v=aYs7IxMQzgg">video</a>)</p>
                </section>
                <section>
                    <h3>Initial state</h3>
                    <p>All containers start with exactly the same state which is derived from the image they are instantiated from.</p>
                </section>
                <section>
                    <h3>What exactly is state?</h3>
                    <ul>
                    </ul>
                </section>
                <section>
                    <h3>What exactly is state?</h3>
                    <ul>
                        <li>Our Database!</li>
                    </ul>
                </section>
                <section>
                    <h3>What exactly is state?</h3>
                    <ul>
                        <li>Our Database!</li>
                        <li>Filesystem (volumes)</li>
                    </ul>
                </section>
                <section>
                    <h3>What exactly is state?</h3>
                    <ul>
                        <li>Our Database!</li>
                        <li>Filesystem (volumes)</li>
                        <li>Configuration (service discovery)</li>
                    </ul>
                </section>
                <section>
                    <h3>What exactly is state?</h3>
                    <ul>
                        <li>Our Database!</li>
                        <li>Filesystem (volumes)</li>
                        <li>Configuration (service discovery)</li>
                        <li>Secrets</li>
                    </ul>
                </section>
                <section>
                    <h3>What exactly is state?</h3>
                    <ul>
                        <li>Our Database!</li>
                        <li>Filesystem (volumes)</li>
                        <li>Configuration (service discovery)</li>
                        <li>Secrets</li>
                        <li>Source Code?</li>
                    </ul>
                </section>
                <section>
                    <h3>Managing Volumes</h3>
                    <ul>
                        <li>Normal Docker volumes are per host</li>
                        <li>Kubernetes Persistent volumes</li>
                        <li>Docker Engine 1.9 includes redesigned volume system with more plugins (eg <a href="https://docs.clusterhq.com/en/1.7.1/introduction/what-is-flocker.html">Flocker</a>)</li>
                    </ul>
                </section>
                <section class="image-slide">
                    <h2>Managing state - CAP</h2>
                    <p>Managing state can be tricky</p>
                    <img src="img/cap.png" alt="CAP" height="600" width="800">
                    <aside class="notes">
                      Managing state in clustered environments is not
                      unique to Docker. There are many database
                      solutions, each with its own pros and cons.
                    </aside>
                </section>
                <section>
                    <h3>Patterns for Managing State</h3>
                    <ul>
                        <li>Outside the cluster (SEP)</li>
                        <li>Adapted to run in cluster (eg MySQL inside cluster with data volume for persistence)</li>
                        <li>Cluster native (eg Cassandra or Riak)</li>
                        <li><a href="http://vitess.io/">vitess.io</a></li>
                    </ul>
                </section>
                </section>

                <section>
                <section>
                    <h3>Patterns for Composite Containers</h3>
                    <p>
                    <a href="http://blog.kubernetes.io/2015/06/the-distributed-system-toolkit-patterns.html">http://blog.kubernetes.io/2015/06/the-distributed-system-toolkit-patterns.html</a> (<a href=blog/">local</a>).
                    </p>
                    <ul>
                        <li>Sidecar containers (eg logger, git synchroniser)</li>
                        <li>Ambassador containers (local proxy to a service of unknown size)</li>
                        <li>Adapter containers (normalize and abstract different services)</li>
                    </ul>
                </section>
                <section class="image-slide">
                    <h2>Sidecar containers</h2>
                    <ul>
                        <li>Modular and pluggable</li>
                        <li>Reuse sidecar for different frontends</li>
                        <li>Different team can maintain the sidecar</li>
                        <li>Lower complexity inside specific containers</li>
                    </ul>
                    <img src="img/sidecar.png" alt="Sidecar">
                    <aside class="notes">
                      Sidecar containers provide re-usable
                      functionality that enhances
                      another container.
                      <br>
                      The example here shows a webserver container server files from
                      a data volume. The data volume is shared with a
                      sidecar container that synchronises the files
                      with a Git repository, thus providing Git
                      push-to-deploy. The sidecar can be re-used to
                      provide git-syncing in other contexts.
                    </aside>
                </section>
                <section class="image-slide">
                    <h2>Ambassador containers</h2>
                    <ul>
                        <li>Its a proxy ...</li>
                        <li>The solution behind the proxy can be as simple or complicated as the environment requires</li>
                        <li>Also modular, reuse, lower complexity per container</li>
                    </ul>
                    <img src="img/ambassador.png" alt="Ambassador">
                    <aside class="notes">
                      Example is of an ambassador container to act
                      like a normal redis server, while it is really a
                      proxy for a redis cluster.
                    </aside>
                </section>
                <section class="image-slide">
                    <h2>Adapter containers</h2>
                    <ul>
                        <li>When containers want to talk to other systems</li>
                        <li>Use adaptors to translate so that neither ends needs native support for each other protocols</li>
                        <li>eg, monitoring systems, convert from app specific output to monitoring system format</li>
                    </ul>
                    <img src="img/adapter.png" alt="Adapter">
                    <aside class="notes">
                      In the example, the redis logs are converted
                      into a standard format by an adapter container,
                      so that the monitoring system only needs to know
                      the standard format that all adapters provide.
                    </aside>
                </section>
                </section>

                <!-- Security -->
                <section>
                <section>
                    <h3>Security</h3>
                    <ul>
                        <li>How do you keep track of all the versions of all the software in all the containers?</li>
                        <li>The way to apply security updates is to update the base image, then rebuild your application image</li>
                        <li>If you release often then include an updated base every time you release (plus special releases for heartbleeds)</li>
                        <li>If you release infrequently then do base update releases of your app</li>
                    </ul>
                </section>
                <section>
                    <h3>Security - Image Signing</h3>
                    <ul>
                        <li><a href="https://blog.docker.com/2015/08/content-trust-docker-1-8/">Intoduction to Docker Content Trust</a></li>
                        <li>Provided by the <a href="https://github.com/docker/notary">Notary</a> open source project</li>
                        <li>Based on <a href="http://theupdateframework.com/">The Update Framework</a></li>
                        <li><a href="https://www.youtube.com/watch?v=at72dhg-SZY&feature=youtu.be&t=4873">Video</a></li>
                        <li><a href="https://docs.docker.com/engine/security/trust/content_trust/">Content Trust Documentation</a></li>
                    </ul>
                    <aside class="notes"><ul>
                      <li>Notary is a general purpose tool for signing files.</li>
                      <li>You can enable "Docker Content Trust" so that you can sign images that other Docker uses can verify.</li>
                      <li>Currently only available with DockerHub.</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>Security - Image Vulnerability Scanning</h3>
                    <ul>
                        <li><a href="https://coreos.com/blog/vulnerability-analysis-for-containers/">Intoduction to Clair from CoreOS</a></li>
                        <li><a href="https://github.com/coreos/clair">Clair on github</a></li>
                        <li>Project Nautilus a new image scanning and vulnerability detection service for Official Repos on Docker Hub</li>
                    </ul>
                </section>
                <section>
                    <h3>Security - Useful links</h3>
                    <ul>
                        <li>How often do the official base images get updated? (details <a href="https://blog.docker.com/2015/06/understanding-official-repos-docker-hub/">here</a>)</li>
                        <li><a href="https://titanous.com/posts/docker-insecurity">Image signing</a> (see <a href="https://github.com/docker/notary">notary</a>)</li>
                        <li><a href="https://securityblog.redhat.com/2014/12/17/container-security-isolation-heaven-or-dependency-hell/">Level of isolation</a></li>
                        <li><a href="https://d3oypxn00j2a10.cloudfront.net/assets/img/docker%20Security/WP_Intro_to_container_security_03.20.2015.pdf">Introduction to Container Security</a> Whitepaper</li>
                        <li><a href="https://blog.docker.com/2013/08/containers-docker-how-secure-are-they/">Fundamentals</a> (old but informative)</li>
                        <li><a href="http://linux-audit.com/docker-security-best-practices-for-your-vessel-and-containers/">Best practices</a></li>
                        <li><a href="https://securityblog.redhat.com/2014/12/18/before-you-initiate-a-docker-pull/">Securely downloading containers</a></li>
                    </ul>
                    <aside class="notes"><ul>
                      <li>Information about official repos</li>
                      <li>Existing issues with image verification.</li>
                      <li>Limitations of containers (Shared kernel etc.)</li>
                      <li>Whitepaper on container security</li>
                      <li>Explanation of how Docker works, security implications, and comparisons to VMs and other containerization systems.</li>
                      <li>Best practice recommendations</li>
                      <li>Problems with Docker pull (auto-unpacking), and how to work around it.</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>Other problems</h3>
                    <ul>
                        <li>Not declarative (Dockerfiles)</li>
                        <li>Not idempotent or repeatable (E.g. apt-get install)</li>
                        <li><a href="https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/">Pids and spawning issues</a> (Zombie processes)</li>
                        <li>Standardisation</li>
                        <li>See <a href="https://www.youtube.com/watch?v=wpFrkq5XNFM">these</a> <a href="https://www.youtube.com/watch?v=et7BCV_kAUY">talks</a> from systemd.conf</li>
                    </ul>
                </section>
                </section>

                <section>
                <section>
                    <h3>Monitoring</h3>
                    <p>Q: How can I monitor my containers?</p>
                    <p>A: Try sysdig/csysdig</p>
                    <ul>
                        <li>sudo csysdig</li>
                        <li>hit F2 and choose the Containers view</li>
                        <li>can also monitor <a href="http://blog.kubernetes.io/2015/11/monitoring-Kubernetes-with-Sysdig.html">kubernetes</a></li>
                    </ul>
                    <aside class="notes">csysdig has a curses UI.</aside>
                </section>
                <section>
                    <h3>Monitoring</h3>
                    <p>Lets build a Docker image for some testing:</p>
                    <pre><code data-trim contenteditable>
$ cat ~/src/docker-training/dockerfiles/stress-testing/dockerfile
$ sudo docker build -t stress-test ~/src/docker-training/dockerfiles/stress-testing/
$ sudo docker run stress-test stress --help
$ sudo docker run [DOCKER OPTIONS] stress-test stress [STRESS OPTIONS]
                    </code></pre>
                </section>
                <section>
                    <h3>Monitoring and CPU limits</h3>
                    <p>Run this command while watching csysdig and htop in other terminals</p>
                    <pre><code data-trim contenteditable>
$ sudo docker run --cpuset-cpus=0,1 stress-test stress -c 3
# in another terminal
$ sudo csysdig
# in another terminal
$ sudo htop
                    </code></pre>
                    <aside class="notes">
                      Here we limit Docker to using the first 2 CPUs (0 and 1).
                      <br>
                      htop shows usage per CPU.
                    </aside>
                </section>
                <section>
                    <h3>Monitoring and Memory limits</h3>
                    <p>Run this command while watching csysdig and htop in other terminals</p>
                    <pre><code data-trim contenteditable>
$ sudo docker run -m 512M stress-test stress --vm-bytes 256M -m 4
# in another terminal
$ sudo csysdig
# in another terminal
$ sudo htop
                    </code></pre>
                    <aside class="notes">
                      Limit the container to 512MB of RAM and 512MB of swap.
                    </aside>
                </section>
                <section>
                    <h3>Monitoring - check-config</h3>
                    <p>How to enable swap limiting:</p>
                    <pre><code data-trim contenteditable>
$ check-config.sh # Check that the kernel supports it.
# Edit /etc/default/grub:
# GRUB_CMDLINE_LINUX="cgroup_enable=memory swapaccount=1"
                    </code></pre>
                </section>
                </section>

                <section>
                <section>
                    <h3>FAQ</h3>
                    <ul>
                        <li><a href="http://www.projectatomic.io/blog/2015/08/why-we-dont-let-non-root-users-run-docker-in-centos-fedora-or-rhel/">Why is sudo required?</a></li>
                        <li><a href="http://www.projectatomic.io/blog/2015/07/what-are-docker-none-none-images/">What are the &lt;none&gt;&lt;none&gt; images I see and how can I clean them up?</a></li>
                        <li><a href="https://docs.docker.com/articles/baseimages/">Can I build my own base image?</a></li>
                        <li><a href="https://stackoverflow.com/questions/24394243/why-are-docker-container-images-so-large">Why are Docker images so large?</a></li>
                        <li><a href="http://thenewstack.io/understanding-the-docker-cache-for-faster-builds/">Does each Dockerfile run command create its own layer?</a></li>
                        <li><a href="https://blog.docker.com/2015/11/docker-multi-host-networking-ga/">What happened to Docker links?</a></li>
                    </ul>
                    <aside class="notes"><ul>
                      <li>sudo is required for kernel features</li>
                      <li>Dangling images (name has been re-used for another image).</li>
                      <li>There is a guide</li>
                      <li>All dependencies from all layers, clean up package manager files to reduce size.</li>
                      <li>Yes</li>
                      <li>Docker's networking has been re-worked to not use links.</li>
                    </ul></aside>
                </section>
                <section>
                    <h3>FAQ</h3>
                    <p>Q: Whats the story with Docker top pids?</p>
                    <pre><code data-trim contenteditable>
$ sudo docker top sleepy_cori
UID  PID   PPID C STIME TTY    TIME     CMD
root 30136 2379 0 12:29 pts/32 00:00:00 /bin/bash

$ pstree -s -p $(sudo docker top sleepy_cori | tail -1 | awk '{ print $2 }')
init(1)docker(2379)bash(30136)
                    </code></pre>
                    <p>A: Top pids are host pids not namespaces container pids</p>
                </section>
                <section>
                    <h3>FAQ</h3>
                    <p>Q: Should I include my application source code in the image?</p>
                    <p>A: It depends, some people like to mount application source code as <a href-"http://blog.ionic.io/docker-hot-code-deploys/">volume</a>, others checkout source code when <a href="http://michal.karzynski.pl/blog/2015/04/19/packaging-django-applications-as-docker-container-images/">building the image</a>.</p>
                    <p>If you are checking out source code in your Dockerfile you need to be aware of <a href="http://thenewstack.io/understanding-the-docker-cache-for-faster-builds/">how caching works</a>.</p>
                </section>
                <section>
                    <h3>FAQ: Copy vs. Add</h3>
                    <p>Q: Should I use Copy or Add in my Dockerfile?</p>
                    <p>A: Use copy unless you actually need the magic add provides (details <a href="https://labs.ctl.io/dockerfile-add-vs-copy/">here</a>).</p>
                </section>
                <section>
                    <h3>FAQ: Docker on the Catalyst Cloud</h3>
                    <p>Q: Whats the easiest way to use Docker on the Catalyst Cloud?</p>
                    <p>A: Have a look at <a href="http://docs.catalystcloud.io/tutorials.html#using-docker-machine-on-the-catalyst-cloud">this tutorial</a> on how to use Docker machine to provision Docker engines on the the Catalyst Cloud</p>
                </section>
                <section>
                    <h3>FAQ: Stop vs. Remove</h3>
                    <p>Q: Are container really ephemeral?</p>
                    <p>A: Stopping a container does not delete its filesystem, it will still be there in /var/lib/docker when you start it again. You need to call Docker rm to delete a container</p>
                </section>
                <section>
                    <h3>FAQ: Mounting volumes in running containers</h3>
                    <p>Q: Can I mount a volume in a running container?</p>
                    <p>A: Its <a href="https://github.com/docker/docker/issues/9849">not currently supported</a> by the CLI but there are some <a href="https://jpetazzo.github.io/2015/01/13/docker-mount-dynamic-volumes/">hacks</a> out there.</p>
                </section>
                <section>
                    <h3>FAQ: History</h3>
                    <p>Q: Can you tell me more about the history of containers and their underlying technologies?</p>
                    <p>A: Watch <a href="https://www.youtube.com/watch?v=YsYzMPptB-k">this talk</a> by Kernel developer James Bottomley at the Tokyo OpenStack summit</p>
                </section>
                <section>
                    <h3>FAQ: Exec vs. shell CMD</h3>
                    <p>Q: Why is it better to use the exec version rather than the shell version of CMD/ENTRYPOINT?</p>
                    <p>A: As our command is not pid 1 we cannot send POSIX signals to our command</p>
                    <p>A: /bin/sh may not be available in minimal containers</p>
                    <p>More info <a href="https://www.ctl.io/developers/blog/post/dockerfile-entrypoint-vs-cmd/">here</a></p>
                    <p>More info about signals <a href="https://labs.ctl.io/gracefully-stopping-docker-containers/">here</a></p>
                </section>
                <section>
                    <h3>FAQ: Docker log rotation</h3>
                    <p>Q: Is logfile rotation configurable?</p>
                    <p>A: <a href="https://docs.docker.com/engine/reference/logging/overview/">Yes</a>.</p>
                </section>
                <section>
                    <h3>FAQ: Digest broken?</h3>
                    <p>Q: Why does the digest command not work?</p>
                    <p>A: You tell me ...</p>
                </section>
                <section>
                    <h3>FAQ: RUN command chaining</h3>
                    <p>Q: Why do you see so many commands chained together on Dockerfile RUN lines?</p>
                    <p>A: There used to be a limited number of layers (was 42 now 127)</p>
                    <p>A: Minimising layers is <a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">encouraged</a></p>
                    <p>A: Multiple RUN lines can lead to caching related <a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">problems</a></p>
                </section>
                </section>

                <section>
                <section>
                    <h3>Next steps</h3>
                    <p>What would you like to see in an intermediate Docker course?</p>
                </section>
                <section>
                    <h3>Next steps</h3>
                    <ul>
                        <li>Setup private registry</li>
                        <li>Students build custom "microservices"</li>
                        <li>Setup CoreOS on OpenStack</li>
                        <li>Deploy students microservices and create a www router service</li>
                        <li>Define service as a kubernetes pod/service</li>
                        <li>Scale and migrate pods (between OpenStack regions?)</li>
                        <li>Continuous delivery?</li>
                        <li>Let me know!</li>
                    </ul>
                </section>
                </section>

                <section>
                    <h3>Sources</h3>
                    <p>Sources of the material used in this course:</p>
                    <ul>
                        <li><a href="https://docs.docker.com/">https://docs.docker.com/</a></li>
                        <li><a href="https://training.docker.com/introduction-to-docker">https://training.docker.com/introduction-to-docker</a></li>
                        <li><a href="http://alandargan.com/using-vagrant-docker/">http://alandargan.com/using-vagrant-docker/</a></li>
                        <li><a href="http://blog.octo.com/en/docker-registry-first-steps/">http://blog.octo.com/en/docker-registry-first-steps/</a></li>
                        <li><a href="https://www.digitalocean.com/community/tutorials/the-docker-ecosystem-an-introduction-to-common-components">https://www.digitalocean.com/community/tutorials/the-docker-ecosystem-an-introduction-to-common-components</a></li>
                        <li><a href="http://radar.oreilly.com/2015/07/set-up-kubernetes-with-a-docker-compose-one-liner.html">http://radar.oreilly.com/2015/07/set-up-kubernetes-with-a-docker-compose-one-liner.html</a></li>
                        <li><a href="http://www.linuxjournal.com/content/concerning-containers-connections-docker-networking">http://www.linuxjournal.com/content/concerning-containers-connections-docker-networking</a></li>
                    </ul>

                </section>
    <section>
        <h3>Basic Docker Examples</h3>
        <ul>
            <li>Run "Hello, World" in a container</li>
            <li>Interact with a container</li>
            <li>Daemonise a container</li>
        </ul>
    </section>
    <section>
        <h3>More Examples</h3>
    </section>

                    <section>
                        <h3>Persist changes to a container</h3>
                        <pre>$ docker run -t -i ubuntu:14.04 /bin/bash

root@69079aaaaab1:/# apt-get update

$ docker commit 69079aaaaab1 ubuntu:update
13132d42da3cc40e8d8b4601a7e2f4dbf198e9d72e37e19ee1986c280ffcb97c

$ docker images
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE
ubuntu update 13132d42da3c 5 days ago 213 MB

$ docker diff &lt;container&gt;
                        </pre>

                    </section>
                    <section>
                        <h3>Saving an image as tar for sharing</h3>
                        <pre>$ docker ps -a

CONTAINER ID IMAGE COMMAND CREATED ... NAMES
77d9619a7a71 ubuntu:14.04 "/bin/bash" 10 seconds ago ... high_shockley

$ docker export 77d9619a7a71 > update.tar
$ ls
update.tar

$ docker import - update &lt; update.tar
157bcbb5fdfce0e7c10ef67ebdba737a491214708a5f266a3c74aa6b0cfde078

$ docker images
REPOSITORY TAG IMAGE ID ... VIRTUAL SIZE
update latest 157bcbb5fdfc ... 188.1 MB
                        </pre>
                    </section>
        </div>


        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>

            // Full list of configuration options available here:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
                transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none

                // Parallax scrolling
                // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
                // parallaxBackgroundSize: '2100px 900px',

                // Optional libraries used to extend on reveal.js
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
                ]
            });

        </script>

    </body>
</html>
